<% include ./partials/header %>


<div class="ui main text container">
    <form action="/analysis" method="POST" class="ui form" id="start-form">
        <input type="submit" class="ui green button" value="Start">
        <input type="button" class="ui red button" value="Stop" id="stop-button">
    </form>

</div>
<div id="analysis-container"></div>


<script>
// TODO - holding all data on clientside is probably not good. Change this to only hold most recent
    var stopBtn         = $('#stop-button'),
        queue           = [], // will hold all data received from server
        interval        = 10000, // timer interval for plotting
        socket          = io(),
        plottingStarted = false;


	socket.on('connect', function(){
		console.log("Socket connected from Client-side");
		console.log(socket.id);
    });

	socket.on('stdout', function(data){
		// keep all data stored in queue array
		queue.push(data);

		// i.e is this is the first time data has been received
		if (!plottingStarted){

			// setup interval to trigger plotting every given interval
			var chartTimer = setInterval(function(){
				console.log("Timer triggered...");
				console.log(queue[queue.length - 1]);
				change(queue[queue.length - 1]);
            }, interval);

			plottingStarted = true;

			// initiate the stop button listener, only after the user has started analysis
			onStop(chartTimer);
        }
    });

	var timer = setInterval(function(){
		socket.emit('love', "Client-side sends some lovin'");
    }, 10000);


	// function that stops all interval timers and kills child process when stop button pressed
	function onStop(chartTimer){
		stopBtn.click(function(event){
			clearInterval(timer);
			clearInterval(chartTimer);
			socket.emit('kill');
		});
    }

    // set the initial sizing variables for the chart
    var width        = 960,
        height       = 450,
        radius       = Math.min(width, height) / 2,
        padAngle     = 0.01,
        cornerRadius = 4;


	var svg = d3.select('#analysis-container')
        .append('svg')
        .append('g');

	svg.append('g')
        .attr('class', 'slices');

	svg.append('g')
        .attr('class', 'labelName');

	svg.append('g')
		.attr('class', 'labelValue');

	svg.append('g')
		.attr('class', 'lines');

	var pie = d3.pie()
        .sort(null)
        .value(function(d){
        	return d.prob;
        });

	var arc = d3.arc()
        .outerRadius(radius * 0.8)
        .innerRadius(radius * 0.6)
        .cornerRadius(cornerRadius)
        .padAngle(padAngle);


	var outerArc = d3.arc()
        .innerRadius(radius * 0.9)
        .outerRadius(radius * 0.9);

	var legendRectSize = radius * 0.05,
        legendSpacing  = radius * 0.02;

	var div = d3.select('body')
        .append('div')
        .attr('class', 'toolTip');

	svg.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

	var colour = d3.scaleOrdinal(d3.schemeCategory20);


	function change(data){

		var chartDiv = document.getElementById('analysis-container');

		var width  = chartDiv.clientWidth,
            height = chartDiv.clientHeight;

		svg.attr('width', width)
            .attr('height', height);

		svg.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

		// PIE SLICES
        var slice = svg.select('.slices')
            .selectAll('path.slice')
            .data(pie(data), function(d){
            	return d.data.species;
            });

        slice.enter()
            .insert('path')
            .style('fill', function(d){
            	return colour(d.data.species);
            })
            .attr('class', 'slice');

        slice.transition().duration(750)
            .attrTween('d', function(d){
                this._current = this._current || d;
                var interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return function(t){
                	return arc(interpolate(t));
                };
            });

        slice.on('mousemove', function(d){
        	div.style('left', d3.event.pageX + 10 + 'px')
                .style('top', d3.event.pageY - 25 + 'px')
                .style('display', 'inline-block')
                .html(d.data.species + '<br>' + d.data.prob * 100 + '%');
        });

        slice.on('mouseout', function(d){
        	div.style('display', 'none');
        });

        slice.exit()
            .remove();

        var legend = svg.selectAll('.legend')
            .data(colour.domain())
            .enter()
            .append('g')
            .attr('class', 'legend')
            .attr('transform', function(d, i){
            	var height = legendRectSize + legendSpacing,
                    offset = height * colour.domain().length / 2,
                    horz   = -3 * legendRectSize,
                    vert   = i * height - offset;
            	return 'translate(' + horz + ',' + vert + ')';
            });

        legend.append('rect')
            .attr('width', legendRectSize)
            .attr('height', legendRectSize)
            .style('fill', colour)
            .style('stroke', colour);

        legend.append('text')
            .attr('x', legendRectSize + legendSpacing)
            .attr('y', legendRectSize - legendSpacing)
            .text(function(d){ return d; });

        // TEXT LABELS

        var text = svg.select('.labelName')
            .selectAll('text')
            .data(pie(data), function(d){
            	return d.data.species;
            });

        text.enter()
            .append('text')
            .attr('dy', '0.35em')
            .text(function(d){
            	return d.data.species + ': ' + d.value * 100 + '%'
            });

        function midAngle(d){
        	return d.startAngle + (d.endAngle - d.startAngle) / 2;
        }

        text.transition().duration(750)
            .attrTween('transform', function(d){
            	this._current = this._current || d;
            	var interpolate = d3.interpolate(this._current, d);
            	this._current = interpolate(0);
            	return function(t){
            		var d2  = interpolate(t),
                        pos = outerArc.centroid(d2);
            		pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
            		return 'translate(' + pos + ')';
                };
            })
            .styleTween('text-anchor', function(d){
            	this._current = this._current || d;
            	var interpolate = d3.interpolate(this._current, d);
            	this._current = interpolate(0);
            	return function(t){
            		var d2 = interpolate(t);
            		return midAngle(d2) < Math.PI ? 'start':'end';
                };
            })
            .text(function(d){
            	return d.data.species + ': ' + d.value * 100 + '%';
            });

        text.exit()
            .remove();


        // SLICE TO TEXT POLYLINES

        var polyline = svg.select('.lines')
            .selectAll('polyline')
            .data(pie(data), function(d){ return d.data.species; });

        polyline.enter()
            .append('polyline');

        polyline.transition().duration(750)
            .attrTween('points', function(d){
            	this._current = this._current || d;
            	var interpolate = d3.interpolate(this._current, d);
            	this._current - interpolate(0);
            	return function(t){
            		var d2  = interpolate(t),
                        pos = outerArc.centroid(d2);
            		pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
            		return [arc.centroid(d2), outerArc.centroid(d2), pos];
                };
            });

        polyline.exit()
            .remove();
    }



    window.addEventListener('resize', change(queue[queue.length - 1]))



</script>

<% include ./partials/footer %>

